# Regular Expression

[source:](https://code.mu/ru/javascript/book/supreme/regular/intro/)

Регулярные выражения - это такие команды для сложного поиска и замены (или просто поиска)

'bab'.replace('a', '!'); // вернет 'b!b'

А вот **точка является специальным символом и обозначает любой символ**. В следующем примере мы найдем строку по такому шаблону: буква 'x', затем любой символ, затем опять буква 'x':

'xax eee'.replace(/x.x/, '!'); // вернет '! eee'

После ограничителей можно писать **модификаторы** - команды, которые изменяют общие свойства регулярного выражения. Например, **модификатор g** включает режим глобального поиска и замены - без него регулярка ищет только первое совпадение, а с ним - все совпадения.

В следующем примере не указан модификатор g и регулярка найдет только первое совпадение:

'aab'.replace(/a/,  '!'); // вернет '!ab'

А теперь регулярка найдет все совпадения:

'aab'.replace(/a/g, '!'); // вернет '!!b'

## Операторы повторения символов в регулярках

Бывают ситуации, когда мы хотим указать, что символ повторяется заданное количество раз. 

Для этого существуют **операторы (*квантификаторы*) повторения**: плюс + (один и более раз), звездочка * (ноль или более раз) и вопрос ? (ноль или один раз). Эти операторы действуют на тот символ, который стоит перед ними.

### Пример
Найдем все подстроки по шаблону буква 'x', буква 'a' один или более раз, буква 'x':

let str = 'xx xax xaax xaaax xbx';

let res = str.replace(/xa+x/g, '!');

В результате в переменную res запишется следующее:

'xx ! ! ! xbx'

### Пример
Найдем все подстроки по шаблону буква 'x', буква 'a' ноль или более раз, буква 'x':

let str = 'xx xax xaax xaaax xbx'

let res = str.replace(/xa*x/g, '!');

В результате в переменную запишется следующее:

'! ! ! ! xbx'

### Пример

Найдем все подстроки по шаблону буква 'x', буква 'a' ноль или один раз, буква 'x':

let str = 'xx xax xaax xbx';

let res = str.replace(/xa?x/g, '!');

В результате в переменную запишется следующее:

'! ! xaax xbx'

## Группирующие скобки в регулярках JavaScript

В предыдущих примерах операторы повторения действовали только на один символ, который стоял перед ними. Что делать, если мы хотим подействовать им на несколько символов?

Для этого существуют **группирующие скобки '(' и ')'.** Они работают так: если что-то стоит в группирующих скобках и сразу после ')' стоит оператор повторения - он подействует на все, что стоит внутри скобок.

Давайте посмотрим на примерах.

### Пример
В следующем примере шаблон поиска выглядит так: буква 'x', далее строка 'ab' один или более раз, потом буква 'x':

let str = 'xabx xababx xaabbx'

let res = str.replace(/x(ab)+x/g, '!');

В результате в переменную запишется следующее:

'! ! xaabbx'

##  Экранировка спецсимволов в регулярках JavaScript

Предположим, что мы хотим сделать так, чтобы спецсимвол обозначал сам себя. Для этого его нужно экранировать с помощью обратного слеша. Давайте посмотрим на примерах.

### Пример
В следующем примере автор регулярки хотел, чтобы шаблон поиска выглядел так: буква 'a', затем плюс '+', затем буква 'x'. Однако, автор кода не заэкранировал символ '+' и поэтому шаблон поиска самом деле он выглядит так: буква 'a' один или более раз, потом буква 'x':

let str = 'a+x ax aax aaax';

let res = str.replace(/a+x/g, '!');

В результате в переменную запишется следующее:

'a+x ! ! !'

### Пример
А сейчас автор заэкранировал плюс обратным слешем. Теперь шаблон поиска выглядит так, как надо: буква 'a', затем плюс '+', затем буква 'x'.

let str = 'a+x ax aax aaax';

let res = str.replace(/a\+x/g, '!');

В результате в переменную запишется следующее:

'! ax aax aaax'

### Пример
В данном примере шаблон выглядит так: буква 'a', затем точка '.', затем буква 'x':

let str = 'a.x abx azx';

let res = str.replace(/a\.x/g, '!');

В результате в переменную запишется следующее:

'! abx azx'

### Пример
А следующем примере автор забыл заэкранировать слеш и под регулярку попали все подстроки, так как незаэкранированная точка обозначает любой символ:

let str = 'a.x abx azx';

let res = str.replace(/a.x/g, '!');

В результате в переменную запишется следующее:

'! ! !'

### Замечание
Обратите внимание на то, что если вы забудете обратный слеш для точки (когда она должна обозначать сама себя) - этого можно даже не заметить:

'a.x'.replace(/a.x/g, '!'); // вернет '!', как мы и хотели
Визуально работает правильно (так как точка обозначает любой символ, в том числе и обычную точку '.'). Но если поменять строку, в которой происходят замены - мы увидим нашу ошибку:

'a.x abx azx'.replace(/a.x/g, '!'); // вернет '! ! !', а ожидалось '! abx azx'

Список специальных символов и обычных
Если экранировать обычный символ - ничего страшного не случится - он все равно будет обозначать сам себя. Исключение - цифры, их нельзя экранировать.

Часто возникает сомнение, является ли данный символ специальным. Некоторые доходят до того, что экранируют все подозрительные символы подряд. Однако, это плохая практика (захламляет регулярку обратными слешами).

- Являются спецсимволами: $ ^ . * + ? \ / {} [] () |

- Не являются спецсимволами: @ : , ' " ; - _ = < > % # ~ `& !

## Фигурные скобки в регулярных выражения JavaScript

Операторы '+', '*', '?' хороши, однако, с их помощью нельзя указать конкретное число повторений. В этом случае вам на помощь придет **оператор {}**.

Работает он следующим образом: {5} - пять повторений, {2,5} – повторяется от двух до пяти (оба включительно), {2,} - повторяется два и более раз. Обратите внимание на то, что такого варианта - {,2} - нет. Посмотрите примеры:

### Пример
В данном примере шаблон поиска выглядит так: буква 'x', буква 'a' один или два раза, буква 'x':

let str = 'xx xax xaax xaaax';

let res = str.replace(/xa{1,2}x/g, '!');

В результате в переменную запишется следующее:

'xx ! ! xaaax'

### Пример
В данном примере шаблон поиска выглядит так: буква 'x', буква 'a' два раза и более, буква 'x':

let str = 'xx xax xaax xaaax';

let res = str.replace(/xa{2,}x/g, '!');

В результате в переменную запишется следующее:

'xx xax ! !'

### Пример
В данном примере шаблон поиска выглядит так: буква 'x', буква 'a' три раза, буква 'x':

let str = 'xx xax xaax xaaax';

let res = str.replace(/xa{3}x/g, '!');

В результате в переменную запишется следующее:

'xx xax xaax !'

### Пример
В данном примере шаблон поиска выглядит так: буква 'a' десять раз:

let str = 'aaa aaaaaaaaaa aaa';

let res = str.replace(/a{10}/g, '!');

В результате в переменную запишется следующее:

'aaa ! aaa'

### Пример
В данном примере автор кода хотел такой шаблон: буква 'x', буква 'a' три раза раза и меньше, буква 'x', но, к сожалению, такое - {,3} - не работает. Нужно указать явно:

let str = 'xx xax xaax xaaax';

let res = str.replace(/xa{1,3}x/g, '!');

В результате в переменную запишется следующее:

'xx ! ! !'

### Пример
Ноль тоже допустим:

let str = 'xx xax xaax xaaax';

let res = str.replace(/xa{0,3}x/g, '!');

В результате в переменную запишется следующее:

'! ! ! !'

## Ограничение жадности в регулярках в JavaScript

Регулярные выражения по умолчанию жадные. Это значит, что они захватывают максимальное возможное количество символов.

Давайте разберем на примере. Пусть у нас есть вот такая строка:

let str = 'aeeex zzz x kkk';

Пусть мы в этой строке хотим найти подстроку 'aeeex' по следующему шаблону: буква 'a', затем любой символ один или более раз, затем буква 'x'.

let res = str.replace(/a.+x/g, '!');

Мы ожидаем, что в переменную res в результате запишется строка '! zzz x kkk'. Однако, это не так - в переменную попадает строка '! kkk'.

Все дело в том, что наша регулярка ищет все символы от буквы 'a' до буквы 'x'. Но в нашей строке две буквы 'x'! Из-за жадности получается, что регулярка ищет до самого последнего икса, тем самым захватывая не то, что мы ожидали.

Конечно, зачастую такое поведение нам и нужно. Но конкретно в этом случае мы бы хотели отменить жадность и сказать регулярке, чтобы она искала до первого икса.

Чтобы ограничить жадность, нужно после оператора повторения поставить **знак вопроса**:

let res = str.replace(/a.+?x/g, '!');

Жадность можно ограничивать всем операторам повторения: и *, и ?, и {} - вот так: *?, ?? и {}?.

## Группы символов в регулярных выражениях JavaScript

Существуют специальные команды, которые позволяют выбрать сразу целые группы символов. Команда **\d означает цифру от 0 до 9**. Команда **\w обозначает цифру, латинскую букву или знак подчеркивания**. Команда **\sобозначает пробел или пробельный символ**: пробел, перевод строки, табуляцию. **Можно инвертировать значение команды, написав большую букву**: например, если \d - цифра, то **\D** - не цифра.

### Пример
Давайте найдем все цифры:

let str = '1 12 123';

let res = str.replace(/\d/g, '!');

В результате в переменную запишется следующее:

'! !! !!!'

### Пример
Операторы повторения считают команды-группы одним целым, то есть группирующие скобки не нужны. В следующем примере шаблон поиска выглядит так: цифра от 0 до 9 один или более раз:

let str = '1 12 123 abc @@@';

let res = str.replace(/\d+/g, '!');

В результате в переменную запишется следующее:

'! ! ! abc @@@'

### Пример
В следующем примере шаблон поиска выглядит так: все что угодно один или более раз, но не цифра от 0 до 9:

let str = '123abc3@@';

let res = str.replace(/\D+/g, '!');

В результате в переменную запишется следующее:

'123!3!'

### Пример
В данном примере шаблон поиска выглядит так: пробельный символ один раз:

let str = '1 12 123 abc @@@';

let res = str.replace(/\s/g, '!');

В результате в переменную запишется следующее:

'1!12!123!abc!@@@'

### Пример
В данном примере шаблон поиска выглядит так: НЕ пробельный символ один или более раз. Все подстроки, разделенные пробелами, заменятся на '!':

let str = '1 12 123 abc @@@';

let res = str.replace(/\S+/g, '!');

В результате в переменную запишется следующее:

'! ! ! ! !'

### Пример
В данном примере шаблон поиска выглядит так: цифра или буква один или более раз. Все подстроки, состоящие из цифр и букв, заменятся на '!':

let str = '1 12 123a Abc @@@';

let res = str.replace(/\w+/g, '!');

В результате в переменную запишется следующее:

'! ! ! ! @@@'

### Пример
В данном примере шаблон поиска выглядит так: НЕ цифра и НЕ буква один или более раз. Под данное определение в нашем случае попадает '@@@' и все пробелы (они ведь тоже не цифры и не буквы). Обратите внимание на то, что в конце один '!' - в него преобразовалась строка ' @@@' - с пробелом впереди:

let str = '1 12 123 Abc @@@';

let res = str.replace(/\W+/g, '!');

В результате в переменную запишется следующее:

'1!12!123!Abc!'

## Наборы символов в регулярных выражениях JavaScript

Группы символов \d и \w не очень гибкие. Даже такая простая задача, как найти все буквы, но не цифры - не может быть решена ими. Для таких задач следует использовать **квадратные скобки, представляющие собой операцию 'или'**.

Квадратные скобки заменяют собой один символ, любой из перечисленных внутри. К примеру, вот так: /x[abc]x/ - мы говорим, что по краям должны стоять буквы икс, а внутри - один символ: или 'a', или 'b', или 'c'.

**После квадратных скобок можно писать операторы повторения**. К примеру, вот так: /x[abc]+x/ - мы говорим, что внутри иксов может быть любое количество символов 'a', 'b' и 'c' - в любых комбинациях.

Можно не только перечислять символы, но **создавать группы символов, записывая между двумя символами дефис**. К примеру, вот так: [a-d] - мы получаем все символы от 'a' до 'd'.

Давайте посмотрим на примерах.

### Пример
В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'z':

let str = 'xax xbx xcx x@x';

let res = str.replace(/x[a-z]x/g, '!');

В результате в переменную запишется следующее:

'! ! ! x@x'

### Пример
В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'k':

let str = 'xax xbx xmx x@x';

let res = str.replace(/x[a-k]x/g, '!');

В результате в переменную запишется следующее:

'! ! xmx x@x'

### Пример
В данном примере шаблон поиска выглядит так: между иксами любая буква от 'A' до 'Z':

let str = 'xax xBx xcx x@x';

let res = str.replace(/x[A-Z]x/g, '!');

В результате в переменную запишется следующее:

'xax ! xcx x@x'

### Пример
В данном примере шаблон поиска выглядит так: между иксами любая цифра от 0 до 9:

let str = 'xax x1x x3x x5x x@x';

let res = str.replace(/x[0-9]x/g, '!');

В результате в переменную запишется следующее:

'xax ! ! ! x@x'

### Пример
В данном примере шаблон поиска выглядит так: между иксами любая цифра от 3 до 7:

let str = 'xax x1x x3x x5x x@x';

let res = str.replace(/x[3-7]x/g, '!');

В результате в переменную запишется следующее:

'xax x1x ! ! x@x'

### Пример
В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'z' или цифра от 1 до 9:

let str = 'xax x1x x3x x5x x@x';

let res = str.replace(/x[a-z1-9]x/g, '!');

В результате в переменную запишется следующее:

'! ! ! ! x@x'

### Пример
В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'z' или буква от 'A' до 'Z':

let str = 'xax xBx xcx x5x x@x';

let res = str.replace(/x[a-zA-Z]x/g, '!');

В результате в переменную запишется следующее:

'! ! ! x5x x@x'

### Пример
В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'z' или цифры 1, 2:

let str = 'xax xbx x1x x2x x3x';

let res = str.replace(/x[a-z12]x/g, '!');

В результате в переменную запишется следующее:

'! ! ! ! x3x'

### Пример
В данном примере шаблон поиска выглядит так: между иксами буквы от 'a' до 'z' в количестве от 1 и более:

let str = 'xx xabesx xaadx x123x xa3x';

let res = str.replace(/x[a-z]+x/g, '!');

В результате в переменную запишется следующее:

'xx ! ! ! x123x xa3x'

### Пример
Сделаем так, чтобы количество букв могло быть и ноль:

let str = 'xx xabesx xaadx x123x xa3x';

let res = str.replace(/x[a-z]*x/g, '!');

В результате в переменную запишется следующее:

'! ! ! ! x123x xa3x'

## Инвертирование наборов символов в регулярках

С помощью **шляпки '^' в начале квадратных скобок можно инвертировать желаемое**. То есть, если, к примеру, команда [ab] ищет букву 'a' или 'b', то команда [^ab] будет искать все символы, кроме 'a' и 'b'.

### Пример
В данном примере шаблон поиска выглядит так: буква 'x', затем НЕ буква 'a', не 'b' и не 'c', потом буква 'z':

let str = 'xaz xbz xcz xez';

let res = str.replace(/x[^abc]z/g, '!');

В результате в переменную запишется следующее:

'xax xbx xcx !'

### Пример
В данном примере шаблон поиска выглядит так: буква 'x', затем НЕ маленькая латинская буква, потом буква 'z':

let str = 'xaz xbz x1z xСz';

let res = str.replace(/x[^a-z]z/g, '!');

В результате в переменную запишется следующее:

'xaz xbz ! !'

## Особенности кириллицы в регулярках JavaScript

Кириллические символы не входят в группу \w. Для их получения нужно использовать группу в квадратных скобках, вот так: [а-я]. Но даже с этой группой есть проблема - сюда не войдет буква 'ё'. Для ее включения нужно сделать вот так: [а-яё].